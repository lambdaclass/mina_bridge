// SPDX-License-Identifier: GPL-3.0
pragma solidity >=0.4.16 <0.9.0;

import "./bn254/Fields.sol";

using {Scalar.mul} for Scalar.FE;

/// This type can be used to create a mapping between powers of alpha and constraint types.
/// See `default()` to create one (not implemented yet),
/// and `register()` to register a new mapping (not implemented yet).
/// Once you know the alpha value, you can convert this type to a `Alphas`.
///
/// Here alpha is a challenge generated by Fiat-Shamir and every constraint (in polynomial
/// form) will get multiplied by a power to make a linearly independent combination
/// (sometimes called the "main polynomial $f$"), of which soundness arguments can be made.
struct Alphas {
    /// The next power of alpha to use.
    /// The end result will be [1, alpha^(next_power - 1)]
    uint next_power;
    /// The mapping between constraint types and powers of alpha */
    mapping(ArgumentType => uint[2]) map;
    /// The powers of alpha: 1, alpha, alpha^2, ..
    /// The array is initially empty until powers are initialized.
    /// If not empty, you can't register new contraints.
    Scalar.FE[] alphas;
}

error CantRegisterNewConstraints();
function register(Alphas storage self, ArgumentType ty, uint powers) {
    if (self.alphas.length != 0) {
        revert CantRegisterNewConstraints();
    }

    if (ty == ArgumentType.GateGeneric ||
        ty == ArgumentType.GatePoseidon ||
        ty == ArgumentType.GateCompleteAdd ||
        ty == ArgumentType.GateVarBaseMul ||
        ty == ArgumentType.GateEndoMul ||
        ty == ArgumentType.GateEndoMulScalar ||
        ty == ArgumentType.GateLookup ||
        ty == ArgumentType.GateCairoClaim ||
        ty == ArgumentType.GateCairoInstruction ||
        ty == ArgumentType.GateCairoFlags ||
        ty == ArgumentType.GateCairoTransition ||
        ty == ArgumentType.GateRangeCheck0 ||
        ty == ArgumentType.GateRangeCheck1 ||
        ty == ArgumentType.GateForeignFieldAdd ||
        ty == ArgumentType.GateForeignFieldMul ||
        ty == ArgumentType.GateXor16 ||
        ty == ArgumentType.GateRot64)
    {
        ty = ArgumentType.GateZero;
    }

    self.map[ty] = [self.next_power, powers];
    self.next_power += powers;
}

/// @notice instantiates the ranges with an actual field element `alpha`.
/// @notice once you call this function, you cannot register new constraints.
function instantiate(Alphas storage self, Scalar.FE alpha) {
    Scalar.FE last_power = Scalar.one();
    Scalar.FE[] memory alphas = new Scalar.FE[](self.next_power);
    alphas[0] = last_power;

    for (uint i = 1; i < self.next_power; i++) {
        last_power = last_power.mul(alpha);
        alphas[i] = last_power;
    }
    self.alphas = alphas;
}

error NotEnoughPowersOfAlpha(uint256 asked_for, uint256 available);
error NonInstantiatedPowersOfAlpha();
/// @notice retrieves the powers of alpha, upperbounded by `num`
function get_alphas(Alphas storage self, ArgumentType ty, uint num)
    view
    returns (AlphasIterator memory)
{
    if (ty == ArgumentType.GateZero ||
        ty == ArgumentType.GateGeneric ||
        ty == ArgumentType.GatePoseidon ||
        ty == ArgumentType.GateCompleteAdd ||
        ty == ArgumentType.GateVarBaseMul ||
        ty == ArgumentType.GateEndoMul ||
        ty == ArgumentType.GateEndoMulScalar ||
        ty == ArgumentType.GateLookup ||
        ty == ArgumentType.GateCairoClaim ||
        ty == ArgumentType.GateCairoInstruction ||
        ty == ArgumentType.GateCairoFlags ||
        ty == ArgumentType.GateCairoTransition ||
        ty == ArgumentType.GateRangeCheck0 ||
        ty == ArgumentType.GateRangeCheck1 ||
        ty == ArgumentType.GateForeignFieldAdd ||
        ty == ArgumentType.GateForeignFieldMul ||
        ty == ArgumentType.GateXor16 ||
        ty == ArgumentType.GateRot64)
    {
        ty = ArgumentType.GateZero;
    }

    uint[2] memory range = self.map[ty];
    if (num > range[1]) {
        revert NotEnoughPowersOfAlpha(num, range[1]);
    }

    if (self.alphas.length == 0) {
        revert NonInstantiatedPowersOfAlpha();
    }

    Scalar.FE[] memory powers = new Scalar.FE[](num);
    for (uint i = 0; i < num; i++) {
        powers[i] = self.alphas[range[0]+i];
    }

    return AlphasIterator(powers, 0);
}

// @notice iterator for retrieving powers of alpha.
// @notice powers are already computed so this should always be entirely consumed.
struct AlphasIterator {
    Scalar.FE[] powers;
    uint256 current_index;
}

function it_next(AlphasIterator memory self) view returns (Scalar.FE) {
    require(self.current_index < self.powers.length, "powers of alpha iterator out of bounds");
    return self.powers[self.current_index++];
}

enum ArgumentType {
    // Gate types
    GateZero,
    GateGeneric,
    GatePoseidon,
    GateCompleteAdd,
    GateVarBaseMul,
    GateEndoMul,
    GateEndoMulScalar,
    GateLookup,
    GateCairoClaim,
    GateCairoInstruction,
    GateCairoFlags,
    GateCairoTransition,
    GateRangeCheck0,
    GateRangeCheck1,
    GateForeignFieldAdd,
    GateForeignFieldMul,
    GateXor16,
    GateRot64,
    // Permutation
    Permutation

    // Lookup
    //Lookup
}
